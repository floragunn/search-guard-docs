

### Whitelisting HTTP headers

By default, Kibana does not pass any HTTP header other than `Authorization` to Elasticsearch. If you try to transmit any other header, it is silently discarded.

In order for SSO to work, make sure that any HTTP header that is required for your configured authentication type is added to the `elasticsearch.requestHeadersWhitelist` configuration entry in `kibana.yml`.

Example:

```yaml
elasticsearch.requestHeadersWhitelist: [ "Authorization", "x-forwarded-for", "x-forwarded-by", "x-proxy-user", "x-proxy-roles" ]
```

**Elasticsearch and Kibana configuration:**

| Elasticsearch Configuration | Kibana Configuration |
|---|---|
| [JSON web token](../_docs_auth_auth/auth_auth_jwt.md) | [JWT Authentication](kibana_authentication_jwt.md) 
| [Proxy authentication](../_docs_auth_auth/auth_auth_proxy.md) | [Proxy Authentication](kibana_authentication_proxy.md) |
| [Kerberos authentication](../_docs_auth_auth/auth_auth_kerberos.md) | [Kerberos Authentication](kibana_authentication_kerberos.md) |
{: .config-table}

## Kibana server user authentication

Regardless which authentication method you choose for your users, the internal Kibana server user will always pass its credentials as base64-encoded HTTP Basic Authentication header. You need to configure at least one Search Guard authentication domain on Elasticsearch side that supports HTTP Basic authentication.

This does not mean that you need to enable Basic Authentication for regular users. The Kibana server user operates under the hood and is independant from user authentication.

## About certificate based authentication

We do not yet provide support for certificate-based (two-way SSL) authentication against Kibana due to technical limitations of the Kibana architecture.